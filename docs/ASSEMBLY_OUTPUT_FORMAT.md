# Chronos Assembly Output Format

**Fecha:** 29 de octubre de 2025
**Target:** x86-64 Linux (System V ABI)
**Formato:** AT&T Syntax (compatible con GNU as)

---

## 1. FORMATO GENERAL

### 1.1 Estructura de Archivo

```asm
# Generated by Chronos Compiler v2.0
# Source: program.ch

.section .data
    # Global variables
    # String literals
    # Constants

.section .rodata
    # Read-only data
    # String literals for immutable &str

.section .bss
    # Uninitialized data

.section .text
    # Code
    .global main
    main:
        # Function body
        ret
```

### 1.2 Comentarios y Metadata

```asm
# Function: factorial
# Source: factorial.ch:10:1
# WCET: 250ns (estimated)
# Stack usage: 32 bytes
```

---

## 2. CALLING CONVENTION (System V AMD64 ABI)

### 2.1 Registro de Parámetros

**Integer/Pointer parameters:**
```
1st param:  %rdi
2nd param:  %rsi
3rd param:  %rdx
4th param:  %rcx
5th param:  %r8
6th param:  %r9
7th+ param: stack (right-to-left)
```

**Float parameters:**
```
1st param:  %xmm0
2nd param:  %xmm1
...
8th param:  %xmm7
9th+ param: stack
```

**Return values:**
```
Integer/Pointer: %rax
Float:           %xmm0
Large structs:   memory (pointer in %rdi)
```

### 2.2 Callee-Saved Registers

**Must preserve:**
```
%rbx, %rbp, %r12, %r13, %r14, %r15
```

**Caller-saved (scratch):**
```
%rax, %rcx, %rdx, %rsi, %rdi, %r8, %r9, %r10, %r11
```

### 2.3 Stack Alignment

- Stack **MUST** be 16-byte aligned before `call`
- Red zone: 128 bytes below %rsp (leaf functions can use)

---

## 3. FUNCTION PROLOGUE/EPILOGUE

### 3.1 Simple Function (No Local Variables)

```asm
# fn simple() -> i32 { return 42; }

simple:
    # Prologue (minimal)
    pushq   %rbp                # Save old base pointer
    movq    %rsp, %rbp          # Set new base pointer

    # Body
    movl    $42, %eax           # Return value

    # Epilogue
    popq    %rbp                # Restore base pointer
    ret
```

### 3.2 Function with Stack Frame

```asm
# fn with_locals() -> i32 {
#     let x: i32 = 10;
#     let y: i32 = 20;
#     return x + y;
# }

with_locals:
    # Prologue
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $16, %rsp           # Allocate 16 bytes (2 x i32 + alignment)

    # Body
    movl    $10, -4(%rbp)       # x = 10
    movl    $20, -8(%rbp)       # y = 20
    movl    -4(%rbp), %eax      # Load x
    addl    -8(%rbp), %eax      # x + y

    # Epilogue
    movq    %rbp, %rsp          # Restore stack pointer
    popq    %rbp
    ret
```

### 3.3 Function with Callee-Saved Registers

```asm
complex_function:
    # Prologue
    pushq   %rbp
    movq    %rsp, %rbp
    pushq   %rbx                # Save callee-saved registers
    pushq   %r12
    pushq   %r13
    subq    $24, %rsp           # Allocate stack space (aligned to 16)

    # Body
    # ... use %rbx, %r12, %r13 ...

    # Epilogue
    addq    $24, %rsp           # Deallocate stack
    popq    %r13                # Restore in reverse order
    popq    %r12
    popq    %rbx
    popq    %rbp
    ret
```

---

## 4. EXPRESIONES

### 4.1 Arithmetic Operations

**Addition:**
```asm
# let c = a + b;
movl    -4(%rbp), %eax      # Load a
addl    -8(%rbp), %eax      # a + b
movl    %eax, -12(%rbp)     # Store c
```

**Multiplication:**
```asm
# let c = a * b;
movl    -4(%rbp), %eax      # Load a
imull   -8(%rbp), %eax      # a * b (signed)
movl    %eax, -12(%rbp)     # Store c
```

**Division (signed):**
```asm
# let c = a / b;
movl    -4(%rbp), %eax      # Load a
cltd                        # Sign-extend %eax to %edx:%eax
idivl   -8(%rbp)            # Signed divide (result in %eax, remainder in %edx)
movl    %eax, -12(%rbp)     # Store c
```

**Modulo:**
```asm
# let c = a % b;
movl    -4(%rbp), %eax      # Load a
cltd                        # Sign-extend
idivl   -8(%rbp)            # Divide
movl    %edx, -12(%rbp)     # Store remainder (in %edx)
```

### 4.2 Comparison Operations

**Equality:**
```asm
# if a == b
movl    -4(%rbp), %eax      # Load a
cmpl    -8(%rbp), %eax      # Compare a with b
je      .L_then             # Jump if equal
# else block
jmp     .L_end
.L_then:
    # then block
.L_end:
```

**Less than:**
```asm
# if a < b
movl    -4(%rbp), %eax      # Load a
cmpl    -8(%rbp), %eax      # Compare
jl      .L_then             # Jump if less
```

**Greater than:**
```asm
# if a > b
movl    -4(%rbp), %eax
cmpl    -8(%rbp), %eax
jg      .L_then
```

### 4.3 Boolean Operations

**Logical AND (short-circuit):**
```asm
# if a && b
movl    -4(%rbp), %eax      # Evaluate a
testl   %eax, %eax          # Test if zero
je      .L_false            # If a is false, skip b
movl    -8(%rbp), %eax      # Evaluate b
testl   %eax, %eax
je      .L_false
# Both true
movl    $1, %eax
jmp     .L_end
.L_false:
    movl    $0, %eax
.L_end:
```

**Logical OR (short-circuit):**
```asm
# if a || b
movl    -4(%rbp), %eax
testl   %eax, %eax
jne     .L_true             # If a is true, done
movl    -8(%rbp), %eax
testl   %eax, %eax
jne     .L_true
# Both false
movl    $0, %eax
jmp     .L_end
.L_true:
    movl    $1, %eax
.L_end:
```

---

## 5. CONTROL FLOW

### 5.1 If Statement

```asm
# if condition {
#     then_block
# } else {
#     else_block
# }

    # Evaluate condition
    movl    condition, %eax
    testl   %eax, %eax
    je      .L_else         # Jump to else if false

.L_then:
    # then_block
    jmp     .L_end

.L_else:
    # else_block

.L_end:
    # Continue
```

### 5.2 While Loop

```asm
# while condition {
#     body
# }

.L_loop_start:
    # Evaluate condition
    movl    condition, %eax
    testl   %eax, %eax
    je      .L_loop_end     # Exit if false

    # body

    jmp     .L_loop_start   # Loop back

.L_loop_end:
    # Continue
```

### 5.3 For Loop (Range)

```asm
# for i in 0..10 {
#     body
# }

    movl    $0, -4(%rbp)    # i = 0

.L_for_start:
    movl    -4(%rbp), %eax  # Load i
    cmpl    $10, %eax       # Compare with 10
    jge     .L_for_end      # Exit if i >= 10

    # body (i is at -4(%rbp))

    incl    -4(%rbp)        # i++
    jmp     .L_for_start

.L_for_end:
```

---

## 6. FUNCTION CALLS

### 6.1 Simple Call

```asm
# let result = add(10, 20);

    movl    $10, %edi       # 1st argument
    movl    $20, %esi       # 2nd argument
    call    add             # Call function
    movl    %eax, -4(%rbp)  # Store result
```

### 6.2 Call with Stack Arguments

```asm
# fn many_args(a: i32, b: i32, c: i32, d: i32, e: i32, f: i32, g: i32, h: i32)

    movl    $1, %edi        # arg1
    movl    $2, %esi        # arg2
    movl    $3, %edx        # arg3
    movl    $4, %ecx        # arg4
    movl    $5, %r8d        # arg5
    movl    $6, %r9d        # arg6
    pushq   $8              # arg8 (right-to-left)
    pushq   $7              # arg7
    call    many_args
    addq    $16, %rsp       # Clean up stack (2 args × 8 bytes)
```

---

## 7. MEMORY ACCESS

### 7.1 Global Variables

```asm
.section .data
    global_var: .long 42

.section .text
    # Load global
    movl    global_var(%rip), %eax    # Position-independent

    # Store global
    movl    $100, %eax
    movl    %eax, global_var(%rip)
```

### 7.2 Local Variables

```asm
# Stack layout:
# %rbp + 0:  saved %rbp
# %rbp - 4:  local var 1 (i32)
# %rbp - 8:  local var 2 (i32)
# %rbp - 16: local var 3 (i64, 8-byte aligned)

    movl    $42, -4(%rbp)       # Store i32
    movq    $1000, -16(%rbp)    # Store i64
```

### 7.3 Array Access

```asm
# let arr: [i32; 10] = ...;
# let x = arr[5];

    leaq    -40(%rbp), %rax     # Base address of array
    movl    $5, %ecx            # Index
    movl    (%rax,%rcx,4), %edx # Load arr[5] (4 = sizeof(i32))
```

**With bounds checking:**
```asm
    movl    $5, %ecx            # Index
    cmpl    $10, %ecx           # Check index < length
    jge     .L_panic            # Panic if out of bounds
    leaq    -40(%rbp), %rax     # Base address
    movl    (%rax,%rcx,4), %edx # Load element
    jmp     .L_continue
.L_panic:
    # Call panic handler
.L_continue:
```

### 7.4 Struct Field Access

```asm
# struct Point { x: i32, y: i32 }
# let p: Point = ...;
# let x_val = p.x;

    leaq    -8(%rbp), %rax      # Address of struct
    movl    0(%rax), %edx       # Load p.x (offset 0)
    movl    4(%rax), %ecx       # Load p.y (offset 4)
```

### 7.5 Pointer Dereference

```asm
# let ptr: *i32 = ...;
# let value = *ptr;

    movq    -8(%rbp), %rax      # Load pointer
    movl    (%rax), %edx        # Dereference
```

---

## 8. DATA SECTION

### 8.1 String Literals

```asm
.section .rodata
    .align 8
.L_str0:
    .quad 11                    # Length (for &str)
    .asciz "Hello World"        # Null-terminated

.section .text
    # Use string
    leaq    .L_str0(%rip), %rdi # Pointer to string
```

### 8.2 Constant Arrays

```asm
.section .rodata
    .align 4
const_array:
    .long 1, 2, 3, 4, 5         # [i32; 5]
```

### 8.3 Global Variables

```asm
.section .data
    .align 8
global_counter:
    .quad 0                     # i64 = 0

.section .bss
    .align 16
large_buffer:
    .zero 1024                  # Reserve 1024 bytes (uninitialized)
```

---

## 9. SPECIAL CONSTRUCTS

### 9.1 Match Expression

```asm
# match value {
#     0 => result1,
#     1 => result2,
#     _ => result3,
# }

    movl    -4(%rbp), %eax      # Load value
    cmpl    $0, %eax
    je      .L_case0
    cmpl    $1, %eax
    je      .L_case1
    jmp     .L_default

.L_case0:
    movl    result1, %eax
    jmp     .L_match_end

.L_case1:
    movl    result2, %eax
    jmp     .L_match_end

.L_default:
    movl    result3, %eax

.L_match_end:
```

### 9.2 Option<T> (enum)

```asm
# enum Option<i32> {
#     None = 0,
#     Some(value)
# }
# Layout:
# +0: discriminant (u8)
# +4: value (i32) - only valid if Some

# Check if Some
    movb    -16(%rbp), %al      # Load discriminant
    cmpb    $1, %al             # Compare with Some
    je      .L_some
# None case
    jmp     .L_none
.L_some:
    movl    -12(%rbp), %eax     # Load value
```

### 9.3 Result<T, E>

```asm
# enum Result<i32, &str> {
#     Ok(i32),
#     Err(&str)
# }
# Layout:
# +0:  discriminant (u8)
# +8:  data (union of i32 or &str)

    movb    -24(%rbp), %al      # Load discriminant
    cmpb    $0, %al             # 0 = Ok
    je      .L_ok
# Err case
    movq    -16(%rbp), %rdi     # Load error string pointer
    call    handle_error
    jmp     .L_end
.L_ok:
    movl    -16(%rbp), %eax     # Load Ok value
.L_end:
```

---

## 10. OPTIMIZATIONS

### 10.1 Dead Code Elimination

**Before:**
```asm
    movl    $42, -4(%rbp)       # x = 42
    movl    $100, -4(%rbp)      # x = 100 (overwrites)
    movl    -4(%rbp), %eax      # Load x
```

**After:**
```asm
    movl    $100, -4(%rbp)      # x = 100 (first assignment removed)
    movl    -4(%rbp), %eax      # Load x
```

### 10.2 Constant Propagation

**Before:**
```asm
    movl    $10, -4(%rbp)       # x = 10
    movl    -4(%rbp), %eax      # Load x
    addl    $20, %eax           # x + 20
```

**After:**
```asm
    movl    $30, %eax           # Result computed at compile-time
```

### 10.3 Register Allocation

**Before (naive):**
```asm
    movl    -4(%rbp), %eax      # Load x
    movl    %eax, -8(%rbp)      # Store temp
    movl    -8(%rbp), %eax      # Load temp
    addl    $1, %eax            # Add 1
```

**After (optimized):**
```asm
    movl    -4(%rbp), %eax      # Load x
    addl    $1, %eax            # Add 1 directly
```

### 10.4 Tail Call Optimization

**Before:**
```asm
factorial:
    # ...
    call    factorial           # Recursive call
    # ... nothing after call ...
    ret
```

**After:**
```asm
factorial:
    # ...
    jmp     factorial           # Tail call (no stack growth)
```

---

## 11. ERROR HANDLING

### 11.1 Panic

```asm
.section .rodata
.L_panic_msg:
    .asciz "panic: index out of bounds"

.section .text
.L_panic:
    leaq    .L_panic_msg(%rip), %rdi
    call    __chronos_panic
    # Never returns
```

### 11.2 Bounds Check

```asm
# arr[index] with bounds checking
    movl    $index, %ecx
    cmpl    $length, %ecx
    jl      .L_in_bounds
    # Out of bounds
    leaq    .L_bounds_error(%rip), %rdi
    call    __chronos_panic
.L_in_bounds:
    # Safe access
```

---

## 12. DEBUGGING INFO

### 12.1 DWARF Debug Info

```asm
    .file   "program.ch"
    .loc    1 10 5              # Line 10, column 5
    movl    $42, %eax
    .loc    1 11 5              # Line 11, column 5
    ret
```

### 12.2 Stack Frame Info

```asm
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    # ...
    popq    %rbp
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc
```

---

## 13. COMPLETE EXAMPLE

### Source Code
```chronos
fn fibonacci(n: i32) -> i32 {
    if n <= 1 {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

fn main() -> i32 {
    let result = fibonacci(10);
    return result;
}
```

### Generated Assembly
```asm
# Generated by Chronos Compiler v2.0

.section .text

.global fibonacci
fibonacci:
    # Prologue
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $16, %rsp           # Stack frame

    # Save parameter n
    movl    %edi, -4(%rbp)

    # if n <= 1
    movl    -4(%rbp), %eax
    cmpl    $1, %eax
    jg      .L_else

.L_then:
    # return n
    movl    -4(%rbp), %eax
    jmp     .L_fib_end

.L_else:
    # fibonacci(n - 1)
    movl    -4(%rbp), %eax
    subl    $1, %eax
    movl    %eax, %edi
    call    fibonacci
    movl    %eax, -8(%rbp)      # Save result

    # fibonacci(n - 2)
    movl    -4(%rbp), %eax
    subl    $2, %eax
    movl    %eax, %edi
    call    fibonacci

    # Add results
    addl    -8(%rbp), %eax

.L_fib_end:
    # Epilogue
    movq    %rbp, %rsp
    popq    %rbp
    ret

.global main
main:
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $16, %rsp

    # fibonacci(10)
    movl    $10, %edi
    call    fibonacci
    movl    %eax, -4(%rbp)      # result

    # return result
    movl    -4(%rbp), %eax

    movq    %rbp, %rsp
    popq    %rbp
    ret
```

---

## 14. NEXT STEPS

- [ ] Implement code generator for each AST node type
- [ ] Implement register allocator
- [ ] Implement optimization passes
- [ ] Write assembly output to file
- [ ] Integrate with assembler

---

**Firmado:** Chronos Compiler Team
**Versión:** 2.0.0-spec
**Estado:** Ready for codegen implementation
